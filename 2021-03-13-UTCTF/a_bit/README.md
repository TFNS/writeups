# A bit weird (crypto, 986p, 39 solved)

## Description

```
I found this weird RSA looking thing somewhere. Can you break it for me? I managed to find x for you, but I don't know how to solve it without d...
```

We also get source code:

```python
from Crypto.Util import number
from secret import flag
import os

length = 2048
p, q = number.getPrime(length//2), number.getPrime(length//2)
N = p*q
e = 3

m = number.bytes_to_long(flag)
x = number.bytes_to_long(os.urandom(length//8))

c = pow(m|x, e, N)
print('N =', N);
print('e =', e);
print('c =', c);
print('m&x =', m&x);
```

And result:

```
N = 13876129555781460073002089038351520612247655754841714940325194761154811715694900213267064079029042442997358889794972854389557630367771777876508793474170741947269348292776484727853353467216624504502363412563718921205109890927597601496686803975210884730367005708579251258930365320553408690272909557812147058458101934416094961654819292033675534518433169541534918719715858981571188058387655828559632455020249603990658414972550914448303438265789951615868454921813881331283621117678174520240951067354671343645161030847894042795249824975975123293970250188757622530156083354425897120362794296499989540418235408089516991225649
e = 3
c = 6581985633799906892057438125576915919729685289065773835188688336898671475090397283236146369846971577536055404744552000913009436345090659234890289251210725630126240983696894267667325908895755610921151796076651419491871249815427670907081328324660532079703528042745484899868019846050803531065674821086527587813490634542863407667629281865859168224431930971680966013847327545587494254199639534463557869211251870726331441006052480498353072578366929904335644501242811360758566122007864009155945266316460389696089058959764212987491632905588143831831973272715981653196928234595155023233235134284082645872266135170511490429493
m&x = 947571396785487533546146461810836349016633316292485079213681708490477178328756478620234135446017364353903883460574081324427546739724

x = 15581107453382746363421172426030468550126181195076252322042322859748260918197659408344673747013982937921433767135271108413165955808652424700637809308565928462367274272294975755415573706749109706624868830430686443947948537923430882747239965780990192617072654390726447304728671150888061906213977961981340995242772304458476566590730032592047868074968609272272687908019911741096824092090512588043445300077973100189180460193467125092550001098696240395535375456357081981657552860000358049631730893603020057137233513015505547751597823505590900290756694837641762534009330797696018713622218806608741753325137365900124739257740
```

## Task analysis

Message is ORed and ANDed with random bitstream `X`.
We know the AND part and X, and also RSA encryption of OR part.

Just from knowing AND part we can recover lost of the bits, but there are too many missing.

Important thing to notice is that `X` is much bigger than `m` (clearly visible from AND part), therefore `m|X` will have MSB bits defined purely by X, so we know prefix of the encrypted message.

## Solution

### Recover OR part

Let's denote MSB of `X` as `prefix` and LSB part ORed with the flag as `y`.
This means we have equation:

```
(prefix+y)^3 mod N = c
```

This means we could create polynomial:

```
(prefix+y)^3 -c mod N == 0
```

And root `y0` of this polynomial would be the missig LSB part we're looking for to recover `X|m`.

We also know that `y` is about 440bits long and `N` has 2048 bits.
Coppersmith method allows us to find small roots of polynomial modular equations as long as root is smaller than `N^(beta^2/d)`.
Beta for our case is 1 (because we don't need a root modulo one of factors of N) and `d=3` because it's the polynomial order.

This means we can find a small root as long as it has less than 1/3 bits of N, and this means below 682 bits.
We need only 440 so we're good.

We can run:

```sage
def main():
    e = 3
    N = 13876129555781460073002089038351520612247655754841714940325194761154811715694900213267064079029042442997358889794972854389557630367771777876508793474170741947269348292776484727853353467216624504502363412563718921205109890927597601496686803975210884730367005708579251258930365320553408690272909557812147058458101934416094961654819292033675534518433169541534918719715858981571188058387655828559632455020249603990658414972550914448303438265789951615868454921813881331283621117678174520240951067354671343645161030847894042795249824975975123293970250188757622530156083354425897120362794296499989540418235408089516991225649
    c = 6581985633799906892057438125576915919729685289065773835188688336898671475090397283236146369846971577536055404744552000913009436345090659234890289251210725630126240983696894267667325908895755610921151796076651419491871249815427670907081328324660532079703528042745484899868019846050803531065674821086527587813490634542863407667629281865859168224431930971680966013847327545587494254199639534463557869211251870726331441006052480498353072578366929904335644501242811360758566122007864009155945266316460389696089058959764212987491632905588143831831973272715981653196928234595155023233235134284082645872266135170511490429493
    x = 15581107453382746363421172426030468550126181195076252322042322859748260918197659408344673747013982937921433767135271108413165955808652424700637809308565928462367274272294975755415573706749109706624868830430686443947948537923430882747239965780990192617072654390726447304728671150888061906213977961981340995242772304458476566590730032592047868074968609272272687908019911741096824092090512588043445300077973100189180460193467125092550001098696240395535375456357081981657552860000358049631730893603020057137233513015505547751597823505590900290756694837641762534009330797696018713622218806608741753325137365900124739257740
    
    bits = 440
    prefix = (x >> bits) << bits
    P.<y> = PolynomialRing(Zmod(N), implementation='NTL')
    pol = (prefix + y)^e - c
    roots = pol.small_roots(beta=1, X=2**bits)
    print("Potential solutions:")
    for root in roots:
       print(int(prefix)+int(root))

main()
```

And we get:
```
15581107453382746363421172426030468550126181195076252322042322859748260918197659408344673747013982937921433767135271108413165955808652424700637809308565928462367274272294975755415573706749109706624868830430686443947948537923430882747239965780990192617072654390726447304728671150888061906213977961981340995242772304458476566590730032592047868074968609272272687908019911741096824092090512588043445300077973100189180460193467125092550001098696240395535375456357081981657552860000358049632085974420042728662283271539219476896698806183845545584152869937049076950347930057423614380871133684001999994749825460312443367450621
```

### Recover flag

Now that we know `x AND flag` and `x OR flag` and also `x` we can recover `flag`.

From `x AND flag` we know all the bits where both `x=1` and `flag=1` (then `x AND flag` has bit 1), and we also know all the bits where `x=1` and `flag=0` (then `x AND flag` has bit 0).

So if `x[i] == 1` then flag bit is the same as `x AND flag` bit.

From `x OR flag` we know all bits where `x=0` and `flag=1` (then `x OR flag` has bit 1) and where `x=0` and `flag=0` (then `x OR flag` has bit 0).

So if `x[i]== 0` then flag bit is the same as `x OR flag` bit.

```python
from crypto_commons.generic import chunk_with_remainder

def solver():
    m_ox = 15581107453382746363421172426030468550126181195076252322042322859748260918197659408344673747013982937921433767135271108413165955808652424700637809308565928462367274272294975755415573706749109706624868830430686443947948537923430882747239965780990192617072654390726447304728671150888061906213977961981340995242772304458476566590730032592047868074968609272272687908019911741096824092090512588043445300077973100189180460193467125092550001098696240395535375456357081981657552860000358049632085974420042728662283271539219476896698806183845545584152869937049076950347930057423614380871133684001999994749825460312443367450621
    m_ax = 947571396785487533546146461810836349016633316292485079213681708490477178328756478620234135446017364353903883460574081324427546739724
    x = 15581107453382746363421172426030468550126181195076252322042322859748260918197659408344673747013982937921433767135271108413165955808652424700637809308565928462367274272294975755415573706749109706624868830430686443947948537923430882747239965780990192617072654390726447304728671150888061906213977961981340995242772304458476566590730032592047868074968609272272687908019911741096824092090512588043445300077973100189180460193467125092550001098696240395535375456357081981657552860000358049631730893603020057137233513015505547751597823505590900290756694837641762534009330797696018713622218806608741753325137365900124739257740
    bits_x_and_m = bin(m_ax).replace("0b", '')[::-1]
    bits_x_or_m = bin(m_ox).replace("0b", '')[::-1]
    bits_x = bin(x).replace("0b", '')[::-1]
    bits_m = ''
    for bit in range(len(bits_x_and_m)):
        if bits_x[bit] == '1':
            bits_m += bits_x_and_m[bit]
        else:
            bits_m += bits_x_or_m[bit]
    print(bits_m)
    chunks = chunk_with_remainder(bits_m, 8)
    chunks = [c[::-1] for c in chunks]
    chunks = chunks[::-1]
    chunks[0] = '0' + chunks[0]
    print(''.join([chr(int(c, 2)) for c in chunks]))


solver()
```

And we get `utflag{C0u1dNt_c0m3_uP_w1tH_A_Cl3veR_f1aG_b61a2defc55f}`
