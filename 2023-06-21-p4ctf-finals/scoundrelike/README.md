# Scoundrelike (re, 11 solves, 277p)

## Introduction

We get a [binary](scoundrelike) to work with.
The binary seems to be a console game, where we can move accross a simple maze and talk to some NPCs, which have tasks for us to complete.

## Reversing

The game has multiple different NPCs.
We can approach any of them, however some of them aren't responsive unless some conditions are met.

### dexor_flag

```c
void dexor_flag(byte *keystream,int offset,int how_many)

{
  int i;
  
  for (i = 0; i < how_many; i = i + 1) {
    (&enc_flag)[i + offset] = (&enc_flag)[i + offset] ^ keystream[i];
  }
  return;
}
```

This function is called multiple times from different places, with different offsets and keystream buffers.
It XORs encrypted flag buffer with given keystream and saves in the encrypted flag buffer.
Eventually the buffer will contain plaintext flag.

### cypis

```c
void cypis(void)

{
  FUN_00103414();
  FUN_00103427(&PTR_s_===+:........................:-._0010c200);
  putchar(10);
  if (DAT_0010ccc0 == 0) {
    if (talked_to_cypis[2] == ' ') {
      print_talk("cypis","What are you waiting for? Go!");
      getchar();
    }
    else {
      print_talk("cypis","Welcome traveler on your quest.");
      print_talk("cypis","Bring me five artifacts of great power and I\'ll reward you generously." );
      print_talk("cypis","The gate is now open. Go if you dare.");
      print_talk("cypis","...");
      print_talk("cypis","Don\'t worry, the challenges are not particularly hard.");
      print_talk("cypis","Actually this is just a token RE task for C reversing enthusiasts.");
      print_talk("cypis","Also I get to generate some ASCII art.");
      print_talk("cypis","Anyway, go on and bring me the items.");
      talked_to_cypis[2] = ' ';
      getchar();
    }
  }
  else {
    print_talk("cypis","Congrats, you got all the items!");
    print_talk("cypis","Not sure why I need them, I don\'t even drink alcohol.");
    print_talk("cypis","(Not since the incident)");
    print_talk("cypis","Anyway, good job! Here\'s your flag.");
    dexor_flag((byte *)&cypis_keystream,0x10,4);
    puts(&enc_flag);
    print_talk("cypis","See you at another finals.");
    getchar();
    game_over();
  }
  return;
}
```

Cypis gives us the quests to work on.
We need to talk to other NPCs and collect some items.
Once this is done he will run dexor_flag for characters 16-20 using value stored in `cypis_keystream`
We can check xrefs to see that this buffer:

```
eternal:00103893(W), des:00103b87(W), rodbert:00103cdf(W), nazywam:0010403c(W)  
```

Each of those NPCs does a simple addition:

```c
cypis_keystream = cypis_keystream + 0x22222222;
cypis_keystream = cypis_keystream + 0x13371337;
cypis_keystream = cypis_keystream + 0x21372137;
cypis_keystream = cypis_keystream + 0x11110101;
```

So we can easily recover this part of keystream.

### rev

This NPC does nothing related to flag.

### dominikoso

Similar to rev, this NPC doesn't do anything with flag buffer.

### des

```c
void des(void)

{
  byte keystream_buffer [10];
  char guess [100];
  int local_14;
  int i;
  int lcg_state;
  
  FUN_00103414();
  FUN_00103427(&PTR_s__0010c640);
  putchar(10);
  print_talk("des","Let\'s play a game");
  print_talk("des","I will help you if you guess three numbers that I think of correctly");
  print_talk("des","Let\'s try that. What number am I thinking about?");
  lcg_state = 0xd;
  i = 0;
  while( true ) {
    if (9 < i) {
      print_talk("des","Wow you\'re very smart.");
      print_talk("des","I will fight for you.");
      des_joined = 1;
      cypis_keystream = cypis_keystream + 0x13371337;
      *(undefined *)(DAT_0010d0a0 + 0x31) = 0x20;
      dexor_flag(keystream_buffer,6,10);
      getchar();
      return;
    }
    read_input(guess);
    local_14 = atoi(guess);
    lcg_state = (lcg_state * 0x7b + 0x141) % 0x100;
    keystream_buffer[i] = (byte)lcg_state;
    if (local_14 != lcg_state) break;
    print_talk("des","Correct! And now?");
    i = i + 1;
  }
  print_talk("des","No, that\'s wrong. Sorry, I can\'t help you.");
  getchar();
  return;
}
```

This NPC will play a game with us: we need to guess 10 numbers.
Numbers are generated by a simple LCG with known initial state, so we can easily generate them to pass the check: [128, 193, 252, 85, 24, 201, 212, 29, 48, 81].
We can also use those numbers to dexor bytes 6-10 from the encrypted flag buffer.

This NPC will also join us if we win the game.
This is important, because this condition is checked by:

```
rodbert:00103c9c(R), nazywam:00103fbf(R)  
```

### rodbert

```c
void rodbert(void)

{
  FUN_00103414();
  FUN_00103427(&PTR_s__0010c840);
  putchar(10);
  print_talk("rodbert","Yes, I will prepare a drink for you.");
  print_talk("rodbert","But only if you find me a good arm wrestling opponent.");
  print_talk("rodbert","I\'ll wait here.");
  if (des_joined != '\0') {
    print("Your companion gets noticed");
    print_talk("rodbert","Finally, a worthy opponent");
    FUN_00103259("margarita (25%)");
    cypis_keystream = cypis_keystream + 0x21372137;
    *(undefined *)(DAT_0010d0a0 + 0x25) = 0x20;
  }
  getchar();
  return;
}
```

This NPC will only modify `cypis_keystream`, and it does that only if we already got joined by des.

### nazywam

```c
void nazywam(void)

{
  FUN_00103414();
  FUN_00103427(&PTR_s__=%#+:_:=+#%@@@@%+-_..._0010ca40);
  putchar(10);
  print_talk("nazywam","[You spot a nice looking doggo]");
  print_talk("nazywam","[You stop for a second to pet him]");
  usleep(1000000);
  if (des_joined == '\0') {
    print_talk("nazywam","[The dog bites you!]");
    print_talk("nazywam","[You\'re bleeding heavily]");
    print_talk("nazywam","[You run away to your safety]");
  }
  else {
    print_talk("nazywam","[The dog tries to bite you!]");
    print("Your companion des saves you from certain death");
    usleep(200000);
    print("Nazywam doesn\'t bite you, but he can hurt you in other ways");
    usleep(200000);
    print("Better go away from here quickly");
    usleep(200000);
    print("Before you go, you notice something lying on the ground");
    cypis_keystream = cypis_keystream + 0x11110101;
    usleep(200000);
    FUN_00103259("yerba mate (0%)");
    *(undefined *)(DAT_0010d050 + 0x2a) = 0x20;
  }
  getchar();
  return;
}
```

Just like rodbert, nazywam also checks if des joined us, and only modifies `cypis_keystream`.

### Eternal

```c
void eternal(void)

{
  int cmp;
  
  FUN_00103414();
  FUN_00103427(&PTR_s__._.._0010c360);
  putchar(10);
  print_talk("eternal","Hey, you!");
  print_talk("eternal","Have you seen my photos?");
  print_talk("eternal","I can\'t talk now, I\'m busy sending emails about the CTF.");
  print_talk("eternal","You know, the upcoming CTF.");
  print_talk("eternal","OK?");
  usleep(500000);
  print_talk("eternal","And I bought some stocks.");
  print_talk("eternal","Do you think it\'ll go up?");
  print_talk("eternal","Sorry I really can\'t talk.");
  usleep(500000);
  print_talk("eternal","Are you hungry? I\'ll give you some food.");
  print_talk("eternal","What do you want?");
  read_input(&eternal_buffer);
  cmp = strcmp(&eternal_buffer,"bug");
  if (cmp == 0) {
    print("You eat the bug and die");
    game_over();
  }
  print_talk("eternal","Ok, ok, here\'s your...");
  print_talk("eternal",&eternal_buffer);
  print_talk("eternal","Ok?");
  print_talk("eternal","I hope it\'s OK.");
  print_talk("eternal","But I really can\'t talk");
  print_talk("eternal","I have to go!");
  print_talk("eternal","See you!");
  usleep(500000);
  print_talk("eternal","Oh and you know what?");
  print_talk("eternal","I\'ll also give you this?");
  FUN_00103259("Freshly squeezed orange juice 0%");
  *(undefined *)(DAT_0010d038 + 0xf) = 0x20;
  cypis_keystream = cypis_keystream + 0x22222222;
  getchar();
  return;
}
```

Just like rodbert and nazywam, eternal will modify `cypis_keystream`, but also store our answer in the `eternal_buffer`, and this buffer is checked by msm.

### msm

```c
void msm(void)

{
  size_t sVar1;
  long hash_value;
  
  FUN_00103414();
  FUN_00103427(&PTR_s__._:..._0010c440);
  putchar(10);
  sVar1 = strlen(&eternal_buffer);
  if (sVar1 < 7) {
    hash_value = hash(&eternal_buffer);
    if (hash_value == 0xc67a3a1d8f87d) {
      print_talk(&DAT_00106ee7,"[msm snatches the food from your hands and disappears]");
      print_talk(&DAT_00106ee7,
                 "[you take a look at the place where msm used to be and notice something]");
      FUN_00103259("kuflowe mocne 7.2%");
      dexor_flag(&eternal_buffer,0,6);
      PTR_0010d098[0xf] = ' ';
      goto LAB_001039a1;
    }
  }
  print_talk(&DAT_00106ee7,"[msm is not pleased with you and says nothing]");
LAB_001039a1:
  getchar();
  return;
}
```

msm checks if the answer we gave to eternal hashes to given constant, and if that's the case, this value is used to dexor bytes 0-6 of the flag.

The hash function is:

```c
ulong hash(byte *buffer)

{
  byte *ptr;
  ulong result;
  
  result = 0;
  for (ptr = buffer; *ptr != 0; ptr = ptr + 1) {
    result = result << 9 ^ (long)(int)(char)(*ptr ^ 0x13);
  }
  return result;
}
```

We can z3 the answer to be `pigeon`

### sasza

```c
void sasza(void)

{
  int cmp;
  size_t sVar1;
  char buffer [30];
  ulong j;
  ulong local_20;
  int i;
  ulong counter;
  
  FUN_00103414();
  FUN_00103427(&PTR_s__:-=+++++++=-:_0010c940);
  putchar(10);
  print_talk("sasza","I\'ll give you your drink if you tell me my secret password.");
  print_talk("sasza","To get the password you need to uhh...");
  print_talk("sasza","[Sasza thinks for a second about an easy RE challenge to give you]");
  print_talk("sasza","Fuck this, I\'ll just tell you the password right away");
  print_talk("sasza","Do you want to hear it (yes/no)?");
  read_input(buffer);
  cmp = strcmp(buffer,"yes");
  if (cmp == 0) {
    print_talk("sasza","Here it goes:");
    counter = 1;
    for (i = 0; i < 0x1e; i = i + 1) {
      local_20 = 0;
      printf(" %lx\n",counter);
      for (j = 0; j < counter; j = j + 1) {
        local_20 = (local_20 + 0x1d) % 0x2aaaaaab;
      }
      putchar((int)local_20 + (int)(local_20 / 0x14) * -0x14 + 0x61);
      fflush(stdout);
      counter = counter << 2;
    }
  }
  else {
    print_talk("sasza","Uhhh, ok?");
  }
  print_talk("sasza","Anyway, give me the password or leave me alone");
  read_input(buffer);
  sVar1 = strlen(buffer);
  if (((sVar1 == 0x1e) && (buffer[0] == 'j')) && (buffer[29] == 'g')) {
    print_talk("sasza","Yeah, it looks similar. Just don\'t cheat here or your flag will be broken. "
              );
    *(undefined *)(DAT_0010d030 + 0x2a) = 0x20;
    FUN_00103259("suspicious moonshine (70%)");
    dexor_flag((byte *)(buffer + 6),0,0x1e);
  }
  else {
    print_talk("sasza","No, did you even listen to what I\'ve said?");
  }
  getchar();
  return;
}
```

sasza is another mini-game.
If we ask for it, NPC will print the secret password, but it takes a very long time.
This password starting at index 6 is then used to dexor the bytes 0-30 of the flag.

It's pretty clear that the inner loop of the password generation can be removed because instead of adding `0x1d` `counter` times, we can simply add `counter*0x1d` instead.

This way we can quickly generate the password: `jqeqeqeqeqeqekohflplplplplplsg`

## Solution

We can grab all the pieces and simply play the game, or we can rewrite the decryption logic:

```python
import binascii

from crypto_commons.generic import xor_string, long_to_bytes


def sasza():
    res = []
    local_10 = 1
    for i in range(0x1e):
        local_20 = 0
        local_20 = (local_20 + 0x1d * local_10) % 0x2aaaaaab
        local_10 = local_10 << 2
        res.append(chr(local_20 + (local_20 // 0x14) * -0x14 + 0x61))
    print('sasza', ''.join(res))
    return ''.join(res)


def des():
    local_c = 0xd
    res = []
    for i in range(10):
        local_c = (local_c * 0x7b + 0x141) % 0x100
        res.append(local_c)
    print('des', res)
    return ''.join([chr(c) for c in res])


def main():
    cypis = long_to_bytes(0x21372137 + 0x22222222 + 0x13371337 + 0x11110101)
    encrypted = binascii.unhexlify('65 2C 79 71 6B 6C 9C F5 E1 58 21 CF D1 02 34 62 87 54 A3 54 16 19 1D 1A'.replace(" ", ""))
    encrypted = xor_string(encrypted, sasza()[6:])
    flag = xor_string(encrypted[0:6], 'pigeon') + xor_string(encrypted[6:16], des()) + xor_string(encrypted[16:20], cypis[::-1]) + encrypted[20:]
    print(flag)


main()
```

Either way, we get: `p4{easy_re_just_for_fun}`
